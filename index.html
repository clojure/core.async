<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.core.async - Facilities for async programming and communication 0.2.x API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">core.async API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">Facilities for async programming and communication</span> <span id="version">0.2.x</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="http://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/*pool-size*" class="toc-entry-anchor">*pool-size*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/&lt;!" class="toc-entry-anchor">&lt;!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/&lt;!!" class="toc-entry-anchor">&lt;!!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/&gt;!" class="toc-entry-anchor">&gt;!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/&gt;!!" class="toc-entry-anchor">&gt;!!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/admix" class="toc-entry-anchor">admix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/alt!" class="toc-entry-anchor">alt!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/alt!!" class="toc-entry-anchor">alt!!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/alts!" class="toc-entry-anchor">alts!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/alts!!" class="toc-entry-anchor">alts!!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/buffer" class="toc-entry-anchor">buffer</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/chan" class="toc-entry-anchor">chan</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/close!" class="toc-entry-anchor">close!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/do-alts" class="toc-entry-anchor">do-alts</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/dropping-buffer" class="toc-entry-anchor">dropping-buffer</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/filter&lt;" class="toc-entry-anchor">filter&lt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/filter&gt;" class="toc-entry-anchor">filter&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/go" class="toc-entry-anchor">go</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/go-loop" class="toc-entry-anchor">go-loop</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/into" class="toc-entry-anchor">into</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/map" class="toc-entry-anchor">map</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/map&lt;" class="toc-entry-anchor">map&lt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/map&gt;" class="toc-entry-anchor">map&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/mapcat&lt;" class="toc-entry-anchor">mapcat&lt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/mapcat&gt;" class="toc-entry-anchor">mapcat&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/merge" class="toc-entry-anchor">merge</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/mix" class="toc-entry-anchor">mix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/mult" class="toc-entry-anchor">mult</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/offer!" class="toc-entry-anchor">offer!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/onto-chan" class="toc-entry-anchor">onto-chan</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/partition" class="toc-entry-anchor">partition</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/partition-by" class="toc-entry-anchor">partition-by</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/pipe" class="toc-entry-anchor">pipe</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/pipeline" class="toc-entry-anchor">pipeline</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/pipeline-async" class="toc-entry-anchor">pipeline-async</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/pipeline-blocking" class="toc-entry-anchor">pipeline-blocking</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/poll!" class="toc-entry-anchor">poll!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/promise-chan" class="toc-entry-anchor">promise-chan</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/pub" class="toc-entry-anchor">pub</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/put!" class="toc-entry-anchor">put!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/reduce" class="toc-entry-anchor">reduce</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/remove&lt;" class="toc-entry-anchor">remove&lt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/remove&gt;" class="toc-entry-anchor">remove&gt;</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/sliding-buffer" class="toc-entry-anchor">sliding-buffer</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/solo-mode" class="toc-entry-anchor">solo-mode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/split" class="toc-entry-anchor">split</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/sub" class="toc-entry-anchor">sub</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/take" class="toc-entry-anchor">take</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/take!" class="toc-entry-anchor">take!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/tap" class="toc-entry-anchor">tap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/thread" class="toc-entry-anchor">thread</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/thread-call" class="toc-entry-anchor">thread-call</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/timeout" class="toc-entry-anchor">timeout</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/to-chan" class="toc-entry-anchor">to-chan</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/toggle" class="toc-entry-anchor">toggle</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/unblocking-buffer?" class="toc-entry-anchor">unblocking-buffer?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/unique" class="toc-entry-anchor">unique</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/unmix" class="toc-entry-anchor">unmix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/unmix-all" class="toc-entry-anchor">unmix-all</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/unsub" class="toc-entry-anchor">unsub</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/unsub-all" class="toc-entry-anchor">unsub-all</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/untap" class="toc-entry-anchor">untap</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async/untap-all" class="toc-entry-anchor">untap-all</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.async.lab">clojure.core.async.lab</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/BroadcastingWritePort" class="toc-entry-anchor">BroadcastingWritePort</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/MultiplexingReadPort" class="toc-entry-anchor">MultiplexingReadPort</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/-&gt;BroadcastingWritePort" class="toc-entry-anchor">-&gt;BroadcastingWritePort</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/-&gt;MultiplexingReadPort" class="toc-entry-anchor">-&gt;MultiplexingReadPort</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/broadcast" class="toc-entry-anchor">broadcast</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/multiplex" class="toc-entry-anchor">multiplex</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.async.lab/spool" class="toc-entry-anchor">spool</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.async">clojure.core.async</span>
  - <span id="header-project">Facilities for async programming and communication</span> <span id="header-version">0.2.x</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.core.async</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/core.async/">http://github.com/clojure/core.async/</a></div>
<pre id="namespace-docstr"></pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/*pool-size*">*pool-size*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Maximum number of threads used for async completion of operations</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L30">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/&lt;!">&lt;!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (&lt;! port)
</pre>
    <pre id="var-docstr">takes a val from port. Must be called inside a (go ...) block. Will
return nil if closed. Will park if nothing is available.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L117">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/&lt;!!">&lt;!!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (&lt;!! port)
</pre>
    <pre id="var-docstr">takes a val from port. Will return nil if closed. Will block
if nothing is available.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L107">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/&gt;!">&gt;!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (&gt;! port val)
</pre>
    <pre id="var-docstr">puts a val into port. nil values are not allowed. Must be called
inside a (go ...) block. Will park if no buffer space is available.
Returns true unless port is already closed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L148">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/&gt;!!">&gt;!!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (&gt;!! port val)
</pre>
    <pre id="var-docstr">puts a val into port. nil values are not allowed. Will block if no
buffer space is available. Returns true unless port is already closed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L138">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/admix">admix</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (admix mix ch)
</pre>
    <pre id="var-docstr">Adds ch as an input to the mix</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L790">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/alt!">alt!</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (alt! &amp; clauses)
</pre>
    <pre id="var-docstr">Makes a single choice between one of several channel operations,
as if by alts!, returning the value of the result expr corresponding
to the operation completed. Must be called inside a (go ...) block.

Each clause takes the form of:

channel-op[s] result-expr

where channel-ops is one of:

take-port - a single port to take
[take-port | [put-port put-val] ...] - a vector of ports as per alts!
:default | :priority - an option for alts!

and result-expr is either a list beginning with a vector, whereupon that
vector will be treated as a binding for the [val port] return of the
operation, else any other expression.

(alt!
  [c t] ([val ch] (foo ch val))
  x ([v] v)
  [[out val]] :wrote
  :default 42)

Each option may appear at most once. The choice and parking
characteristics are those of alts!.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L348">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/alt!!">alt!!</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (alt!! &amp; clauses)
</pre>
    <pre id="var-docstr">Like alt!, except as if by alts!!, will block until completed, and
not intended for use in (go ...) blocks.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L341">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/alts!">alts!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (alts! ports &amp; {:as opts})
</pre>
    <pre id="var-docstr">Completes at most one of several channel operations. Must be called
inside a (go ...) block. ports is a vector of channel endpoints,
which can be either a channel to take from or a vector of
[channel-to-put-to val-to-put], in any combination. Takes will be
made as if by &lt;!, and puts will be made as if by &gt;!. Unless
the :priority option is true, if more than one port operation is
ready a non-deterministic choice will be made. If no operation is
ready and a :default value is supplied, [default-val :default] will
be returned, otherwise alts! will park until the first operation to
become ready completes. Returns [val port] of the completed
operation, where val is the value taken for takes, and a
boolean (true unless already closed, as per put!) for puts.

opts are passed as :key val ... Supported options:

:default val - the value to use if none of the operations are immediately ready
:priority true - (default nil) when true, the operations will be tried in order.

Note: there is no guarantee that the port exps or val exprs will be
used, nor in what order should they be, so they should not be
depended upon for side effects.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L277">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/alts!!">alts!!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (alts!! ports &amp; {:as opts})
</pre>
    <pre id="var-docstr">Like alts!, except takes will be made as if by &lt;!!, and puts will
be made as if by &gt;!!, will block until completed, and not intended
for use in (go ...) blocks.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L266">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/buffer">buffer</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (buffer n)
</pre>
    <pre id="var-docstr">Returns a fixed buffer of size n. When full, puts will block/park.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L51">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/chan">chan</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (chan)
       (chan buf-or-n)
       (chan buf-or-n xform)
       (chan buf-or-n xform ex-handler)
</pre>
    <pre id="var-docstr">Creates a channel with an optional buffer, an optional transducer
(like (map f), (filter p) etc or a composition thereof), and an
optional exception-handler.  If buf-or-n is a number, will create
and use a fixed buffer of that size. If a transducer is supplied a
buffer must be specified. ex-handler must be a fn of one argument -
if an exception occurs during transformation it will be called with
the Throwable as an argument, and any non-nil return value will be
placed in the channel.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L75">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/close!">close!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (close! chan)
</pre>
    <pre id="var-docstr">Closes a channel. The channel will no longer accept any puts (they
will be ignored). Data in the channel remains available for taking, until
exhausted, after which takes will return nil. If there are any
pending takes, they will be dispatched with nil. Closing a closed
channel is a no-op. Returns nil.

Logically closing happens after all puts have been delivered. Therefore, any
blocked or parked puts will remain blocked/parked until a taker releases them.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L178">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/do-alts">do-alts</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (do-alts fret ports opts)
</pre>
    <pre id="var-docstr">returns derefable [val port] if immediate, nil if enqueued</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L237">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/dropping-buffer">dropping-buffer</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (dropping-buffer n)
</pre>
    <pre id="var-docstr">Returns a buffer of size n. When full, puts will complete but
val will be dropped (no transfer).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L56">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/filter&lt;">filter&lt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (filter&lt; p ch)
       (filter&lt; p ch buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1051">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/filter&gt;">filter&gt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (filter&gt; p ch)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1029">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/go">go</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (go &amp; body)
</pre>
    <pre id="var-docstr">Asynchronously executes the body, returning immediately to the
calling thread. Additionally, any visible calls to &lt;!, &gt;! and alt!/alts!
channel operations within the body will block (if necessary) by
'parking' the calling thread rather than tying up an OS thread (or
the only JS thread when in ClojureScript). Upon completion of the
operation, the body will be resumed.

Returns a channel which will receive the result of the body when
completed</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L404">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/go-loop">go-loop</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (go-loop bindings &amp; body)
</pre>
    <pre id="var-docstr">Like (go (loop ...))</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L456">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/into">into</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (into coll ch)
</pre>
    <pre id="var-docstr">Returns a channel containing the single (collection) result of the
items taken from the channel conjoined to the supplied
collection. ch must close before into produces a result.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L956">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/map">map</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map f chs)
       (map f chs buf-or-n)
</pre>
    <pre id="var-docstr">Takes a function and a collection of source channels, and returns a
channel which contains the values produced by applying f to the set
of first items taken from each source channel, followed by applying
f to the set of second items from each channel, until any one of the
channels is closed, at which point the output channel will be
closed. The returned channel will be unbuffered by default, or a
buf-or-n can be supplied</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L902">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/map&lt;">map&lt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map&lt; f ch)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L983">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/map&gt;">map&gt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map&gt; f ch)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1014">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/mapcat&lt;">mapcat&lt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (mapcat&lt; f in)
       (mapcat&lt; f in buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1080">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/mapcat&gt;">mapcat&gt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (mapcat&gt; f out)
       (mapcat&gt; f out buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1088">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/merge">merge</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (merge chs)
       (merge chs buf-or-n)
</pre>
    <pre id="var-docstr">Takes a collection of source channels and returns a channel which
contains all values taken from them. The returned channel will be
unbuffered by default, or a buf-or-n can be supplied. The channel
will close after all the source channels have closed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L938">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/mix">mix</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (mix out)
</pre>
    <pre id="var-docstr">Creates and returns a mix of one or more input channels which will
be put on the supplied out channel. Input sources can be added to
the mix with 'admix', and removed with 'unmix'. A mix supports
soloing, muting and pausing multiple inputs atomically using
'toggle', and can solo using either muting or pausing as determined
by 'solo-mode'.

Each channel can have zero or more boolean modes set via 'toggle':

:solo - when true, only this (ond other soloed) channel(s) will appear
        in the mix output channel. :mute and :pause states of soloed
        channels are ignored. If solo-mode is :mute, non-soloed
        channels are muted, if :pause, non-soloed channels are
        paused.

:mute - muted channels will have their contents consumed but not included in the mix
:pause - paused channels will not have their contents consumed (and thus also not included in the mix)</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L720">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/mult">mult</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (mult ch)
</pre>
    <pre id="var-docstr">Creates and returns a mult(iple) of the supplied channel. Channels
containing copies of the channel can be created with 'tap', and
detached with 'untap'.

Each item is distributed to all taps in parallel and synchronously,
i.e. each tap must accept before the next item is distributed. Use
buffering/windowing to prevent slow taps from holding up the mult.

Items received when there are no taps get dropped.

If a tap puts to a closed channel, it will be removed from the mult.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L653">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/offer!">offer!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (offer! port val)
</pre>
    <pre id="var-docstr">Puts a val into port if it's possible to do so immediately.
nil values are not allowed. Never blocks. Returns true if offer succeeds.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L390">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/onto-chan">onto-chan</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (onto-chan ch coll)
       (onto-chan ch coll close?)
</pre>
    <pre id="var-docstr">Puts the contents of coll into the supplied channel.

By default the channel will be closed after the items are copied,
but can be determined by the close? parameter.

Returns a channel which will close after the items are copied.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L622">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/partition">partition</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (partition n ch)
       (partition n ch buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1114">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/partition-by">partition-by</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (partition-by f ch)
       (partition-by f ch buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1138">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/pipe">pipe</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (pipe from to)
       (pipe from to close?)
</pre>
    <pre id="var-docstr">Takes elements from the from channel and supplies them to the to
channel. By default, the to channel will be closed when the from
channel closes, but can be determined by the close?  parameter. Will
stop consuming the from channel if the to channel closes</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L461">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/pipeline">pipeline</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (pipeline n to xf from)
       (pipeline n to xf from close?)
       (pipeline n to xf from close? ex-handler)
</pre>
    <pre id="var-docstr">Takes elements from the from channel and supplies them to the to
channel, subject to the transducer xf, with parallelism n. Because
it is parallel, the transducer will be applied independently to each
element, not across elements, and may produce zero or more outputs
per input.  Outputs will be returned in order relative to the
inputs. By default, the to channel will be closed when the from
channel closes, but can be determined by the close?  parameter. Will
stop consuming the from channel if the to channel closes. Note this
should be used for computational parallelism. If you have multiple
blocking operations to put in flight, use pipeline-blocking instead,
If you have multiple asynchronous operations to put in flight, use
pipeline-async instead.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L535">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/pipeline-async">pipeline-async</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (pipeline-async n to af from)
       (pipeline-async n to af from close?)
</pre>
    <pre id="var-docstr">Takes elements from the from channel and supplies them to the to
channel, subject to the async function af, with parallelism n. af
must be a function of two arguments, the first an input value and
the second a channel on which to place the result(s). af must close!
the channel before returning.  The presumption is that af will
return immediately, having launched some asynchronous operation
(i.e. in another thread) whose completion/callback will manipulate
the result channel. Outputs will be returned in order relative to
the inputs. By default, the to channel will be closed when the from
channel closes, but can be determined by the close?  parameter. Will
stop consuming the from channel if the to channel closes. See also
pipeline, pipeline-blocking.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L558">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/pipeline-blocking">pipeline-blocking</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (pipeline-blocking n to xf from)
       (pipeline-blocking n to xf from close?)
       (pipeline-blocking n to xf from close? ex-handler)
</pre>
    <pre id="var-docstr">Like pipeline, for blocking operations.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L552">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/poll!">poll!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (poll! port)
</pre>
    <pre id="var-docstr">Takes a val from port if it's possible to do so immediately.
Never blocks. Returns value if successful, nil otherwise.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L397">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/promise-chan">promise-chan</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (promise-chan)
       (promise-chan xform)
       (promise-chan xform ex-handler)
</pre>
    <pre id="var-docstr">Creates a promise channel with an optional transducer, and an optional
exception-handler. A promise channel can take exactly one value that consumers
will receive. Once full, puts complete but val is dropped (no transfer).
Consumers will block until either a value is placed in the channel or the
channel is closed. See chan for the semantics of xform and ex-handler.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L91">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/pub">pub</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (pub ch topic-fn)
       (pub ch topic-fn buf-fn)
</pre>
    <pre id="var-docstr">Creates and returns a pub(lication) of the supplied channel,
partitioned into topics by the topic-fn. topic-fn will be applied to
each value on the channel and the result will determine the 'topic'
on which that value will be put. Channels can be subscribed to
receive copies of topics using 'sub', and unsubscribed using
'unsub'. Each topic will be handled by an internal mult on a
dedicated channel. By default these internal channels are
unbuffered, but a buf-fn can be supplied which, given a topic,
creates a buffer with desired properties.

Each item is distributed to all subs in parallel and synchronously,
i.e. each sub must accept before the next item is distributed. Use
buffering/windowing to prevent slow subs from holding up the pub.

Items received when there are no matching subs get dropped.

Note that if buf-fns are used then each topic is handled
asynchronously, i.e. if a channel is subscribed to more than one
topic it should not expect them to be interleaved identically with
the source.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L827">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/put!">put!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (put! port val)
       (put! port val fn1)
       (put! port val fn1 on-caller?)
</pre>
    <pre id="var-docstr">Asynchronously puts a val into port, calling fn1 (if supplied) when
complete, passing false iff port is already closed. nil values are
not allowed. If on-caller? (default true) is true, and the put is
immediately accepted, will call fn1 on calling thread.  Returns
true unless port is already closed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L158">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/reduce">reduce</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reduce f init ch)
</pre>
    <pre id="var-docstr">f should be a function of 2 arguments. Returns a channel containing
the single result of applying f to init and the first item from the
channel, then applying f to that result and the 2nd item, etc. If
the channel closes without yielding items, returns init and f is not
called. ch must close before reduce produces a result.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L595">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/remove&lt;">remove&lt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (remove&lt; p ch)
       (remove&lt; p ch buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1065">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/remove&gt;">remove&gt;</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (remove&gt; p ch)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1046">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/sliding-buffer">sliding-buffer</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sliding-buffer n)
</pre>
    <pre id="var-docstr">Returns a buffer of size n. When full, puts will complete, and be
buffered, but oldest elements in buffer will be dropped (not
transferred).</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L62">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/solo-mode">solo-mode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (solo-mode mix mode)
</pre>
    <pre id="var-docstr">Sets the solo mode of the mix. mode must be one of :mute or :pause</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L817">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/split">split</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (split p ch)
       (split p ch t-buf-or-n f-buf-or-n)
</pre>
    <pre id="var-docstr">Takes a predicate and a source channel and returns a vector of two
channels, the first of which will contain the values for which the
predicate returned true, the second those for which it returned
false.

The out channels will be unbuffered by default, or two buf-or-ns can
be supplied. The channels will close after the source channel has
closed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L574">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/sub">sub</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (sub p topic ch)
       (sub p topic ch close?)
</pre>
    <pre id="var-docstr">Subscribes a channel to a topic of a pub.

By default the channel will be closed when the source closes,
but can be determined by the close? parameter.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L882">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/take">take</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (take n ch)
       (take n ch buf-or-n)
</pre>
    <pre id="var-docstr">Returns a channel that will return, at most, n items from ch. After n items
 have been returned, or ch has been closed, the return channel will close.

The output channel is unbuffered by default, unless buf-or-n is given.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L964">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/take!">take!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (take! port fn1)
       (take! port fn1 on-caller?)
</pre>
    <pre id="var-docstr">Asynchronously takes a val from port, passing to fn1. Will pass nil
if closed. If on-caller? (default true) is true, and value is
immediately available, will call fn1 on calling thread.
Returns nil.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L123">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/tap">tap</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (tap mult ch)
       (tap mult ch close?)
</pre>
    <pre id="var-docstr">Copies the mult source onto the supplied channel.

By default the channel will be closed when the source closes,
but can be determined by the close? parameter.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L696">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/thread">thread</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (thread &amp; body)
</pre>
    <pre id="var-docstr">Executes the body in another thread, returning immediately to the
calling thread. Returns a channel which will receive the result of
the body when completed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L447">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/thread-call">thread-call</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (thread-call f)
</pre>
    <pre id="var-docstr">Executes f in another thread, returning immediately to the calling
thread. Returns a channel which will receive the result of calling
f when completed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L429">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/timeout">timeout</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (timeout msecs)
</pre>
    <pre id="var-docstr">Returns a channel that will close after msecs</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L102">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/to-chan">to-chan</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (to-chan coll)
</pre>
    <pre id="var-docstr">Creates and returns a channel which contains the contents of coll,
closing when exhausted.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L637">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/toggle">toggle</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (toggle mix state-map)
</pre>
    <pre id="var-docstr">Atomically sets the state(s) of one or more channels in a mix. The
state map is a map of channels -&gt; channel-state-map. A
channel-state-map is a map of attrs -&gt; boolean, where attr is one or
more of :mute, :pause or :solo. Any states supplied are merged with
the current state.

Note that channels can be added to a mix via toggle, which can be
used to add channels in a particular (e.g. paused) state.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L805">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/unblocking-buffer?">unblocking-buffer?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unblocking-buffer? buff)
</pre>
    <pre id="var-docstr">Returns true if a channel created with buff will never block. That is to say,
puts into this buffer will never cause the buffer to be full. </pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L69">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/unique">unique</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unique ch)
       (unique ch buf-or-n)
</pre>
    <pre id="var-docstr">Deprecated - this function will be removed. Use transducer instead</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L1097">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/unmix">unmix</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unmix mix ch)
</pre>
    <pre id="var-docstr">Removes ch as an input to the mix</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L795">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/unmix-all">unmix-all</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unmix-all mix)
</pre>
    <pre id="var-docstr">removes all inputs from the mix</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L800">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/unsub">unsub</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unsub p topic ch)
</pre>
    <pre id="var-docstr">Unsubscribes a channel from a topic of a pub</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L890">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/unsub-all">unsub-all</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (unsub-all p)
       (unsub-all p topic)
</pre>
    <pre id="var-docstr">Unsubscribes all channels from a pub, or a topic of a pub</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L895">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/untap">untap</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (untap mult ch)
</pre>
    <pre id="var-docstr">Disconnects a target channel from a mult</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L704">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async/untap-all">untap-all</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (untap-all mult)
</pre>
    <pre id="var-docstr">Disconnects all target channels from a mult</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/1bee1b534d66373abeb4ea502d12f379516ec063/src/main/clojure/clojure/core/async.clj#L709">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.core.async.lab">clojure.core.async.lab</h2>
<pre id="namespace-docstr">core.async HIGHLY EXPERIMENTAL feature exploration

Caveats:

1. Everything defined in this namespace is experimental, and subject
to change or deletion without warning.

2. Many features provided by this namespace are highly coupled to
implementation details of core.async. Potential features which
operate at higher levels of abstraction are suitable for inclusion
in the examples.

3. Features provided by this namespace MAY be promoted to
clojure.core.async at a later point in time, but there is no
guarantee any of them will.</pre>


<br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/BroadcastingWritePort">BroadcastingWritePort</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[write-ports]</span><br />
    Protocols: <span id="type-protocols">clojure.core.async.impl.protocols/WritePort</span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/MultiplexingReadPort">MultiplexingReadPort</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[mutex read-ports]</span><br />
    Protocols: <span id="type-protocols">clojure.core.async.impl.protocols/ReadPort</span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/-&gt;BroadcastingWritePort">-&gt;BroadcastingWritePort</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;BroadcastingWritePort write-ports)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.async.lab.BroadcastingWritePort.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/ad7ca68a831a1e469b6f30334903279b2e4e43f7/src/main/clojure/clojure/core/async/lab.clj#L93">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/-&gt;MultiplexingReadPort">-&gt;MultiplexingReadPort</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;MultiplexingReadPort mutex read-ports)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.async.lab.MultiplexingReadPort.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/ad7ca68a831a1e469b6f30334903279b2e4e43f7/src/main/clojure/clojure/core/async/lab.clj#L33">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/broadcast">broadcast</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (broadcast &amp; ports)
</pre>
    <pre id="var-docstr">Returns a broadcasting write port which, when written to, writes
the value to each of ports.

Writes to the broadcasting port will park until the value is written
to each of the ports used to create it. For this reason, it is
strongly advised that each of the underlying ports support buffered
writes.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/ad7ca68a831a1e469b6f30334903279b2e4e43f7/src/main/clojure/clojure/core/async/lab.clj#L99">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/multiplex">multiplex</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (multiplex &amp; ports)
</pre>
    <pre id="var-docstr">Returns a multiplexing read port which, when read from, produces a
value from one of ports.

If at read time only one port is available to be read from, the
multiplexing port will return that value. If multiple ports are
available to be read from, the multiplexing port will return one
value from a port chosen non-deterministicly. If no port is
available to be read from, parks execution until a value is
available.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/ad7ca68a831a1e469b6f30334903279b2e4e43f7/src/main/clojure/clojure/core/async/lab.clj#L69">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.async.lab/spool">spool</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (spool s c)
       (spool s)
</pre>
    <pre id="var-docstr">Take a sequence and puts each value on a channel and returns the channel.
If no channel is provided, an unbuffered channel is created. If the
sequence ends, the channel is closed.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.async/blob/ad7ca68a831a1e469b6f30334903279b2e4e43f7/src/main/clojure/clojure/core/async/lab.clj#L112">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2016 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>