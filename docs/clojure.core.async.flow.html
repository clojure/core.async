<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>clojure.core.async.flow documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="flow.html"><div class="inner"><span>core.async.flow</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="clojure.core.async.html"><div class="inner"><span>clojure.core.async</span></div></a></li><li class="depth-1 current"><a href="clojure.core.async.flow.html"><div class="inner"><span>clojure.core.async.flow</span></div></a></li><li class="depth-1 "><a href="clojure.core.async.flow.spi.html"><div class="inner"><span>clojure.core.async.flow.spi</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="clojure.core.async.flow.html#var-command-proc"><div class="inner"><span>command-proc</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-create-flow"><div class="inner"><span>create-flow</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-futurize"><div class="inner"><span>futurize</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-inject"><div class="inner"><span>inject</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-lift*-.3Estep"><div class="inner"><span>lift*-&gt;step</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-lift1-.3Estep"><div class="inner"><span>lift1-&gt;step</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-pause"><div class="inner"><span>pause</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-pause-proc"><div class="inner"><span>pause-proc</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-ping"><div class="inner"><span>ping</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-ping-proc"><div class="inner"><span>ping-proc</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-process"><div class="inner"><span>process</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-resume"><div class="inner"><span>resume</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-resume-proc"><div class="inner"><span>resume-proc</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-start"><div class="inner"><span>start</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-step-process"><div class="inner"><span>step-process</span></div></a></li><li class="depth-1"><a href="clojure.core.async.flow.html#var-stop"><div class="inner"><span>stop</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">clojure.core.async.flow</h1><div class="doc"><pre class="plaintext">
Note - Alpha, work-in-progress, names and other details are in flux 

A library for building concurrent, event driven data processing
flows out of communication-free functions, while centralizing
control, reporting, execution and error handling. Built on core.async.

The top-level construct is the flow, comprising:
a set of processes (generally, threads) - concurrent activities
a set of channels flowing data into and out of the processes
a set of channels for centralized control, reporting, error-handling,
  and execution of the processes

A flow is constructed from flow configuration data which defines a
directed graph of processes and the connections between
them. Processes describe their I/O requirements and the
flow (library) itself creates channels and passes them to the
processes that requested them. See 'create-flow' for the
details. The flow configuration provides a centralized place for
policy decisions regarding process settings, threading, buffering etc.

It is expected that applications will rarely define instances of the
process protocol but instead use the API functions here, 'process'
and 'step-process', that implement the process protocol in terms of
calls to ordinary functions that might include no communication or
core.async code. In this way the library helps you achieve a strict
separation of your application logic from its execution,
communication, lifecycle, error handling and monitoring.

Note that at several points the library calls upon the user to
supply ids for processes, inputs, outputs etc. These should be
keywords. When a namespaced keyword is required it is explicitly
stated. This documentation refers to various keywords utilized by
the library itself as ::flow/xyz, where ::flow is an alias for
clojure.core.async.flow

A process is represented in the flow definition by an implementation
of spi/ProcLauncher that starts it. See the spi docs for
details.</pre></div><div class="public anchor" id="var-command-proc"><h3>command-proc</h3><div class="usage"><code>(command-proc g pid cmd-id more-kvs)</code></div><div class="doc"><pre class="plaintext">synchronously sends a process-specific command with the given id and
additional kvs to the process. The cmd-id must be ns-qualified with
a ns you own.</pre></div></div><div class="public anchor" id="var-create-flow"><h3>create-flow</h3><div class="usage"><code>(create-flow config)</code></div><div class="doc"><pre class="plaintext">Creates a flow from the supplied configuration: a map containing the
keys :procs and :conns, and optionally :mixed-exec/:io-exec/:compute-exec

:procs - a map of pid-&gt;proc-def
where proc-def is a map with keys :proc, :args, :chan-opts

:proc - a function that starts a process
:args - a map of param-&gt;val which will be passed to the process ctor
:chan-opts - a map of in-or-out-id-&gt;{:keys [buf-or-n xform]}, where buf-or-n
             and xform have their meanings per core.async/chan
             the default is {:buf-or-n 10}

:conns - a collection of [[from-pid outid] [to-pid inid]] tuples.

Inputs and outputs support multiple connections. When an output is
connected multiple times every connection will get every message,
as per a core.async/mult.

:mixed-exec/:io-exec/:compute-exec -&gt; ExecutorService
These can be used to specify the ExecutorService to use for the
corresonding workload, in lieu of the lib defaults.

N.B. The flow is not started. See 'start'</pre></div></div><div class="public anchor" id="var-futurize"><h3>futurize</h3><div class="usage"><code>(futurize f &amp; {:keys [exec], :or {exec :mixed}, :as opts})</code></div><div class="doc"><pre class="plaintext">Takes a fn f and returns a fn that takes the same arguments as f
and immediately returns a future, having started a thread for the
indicated workload, or via the supplied executor, that invokes f
with those args and completes that future with its return.

futurize accepts kwarg options:
:exec - one of the workloads :mixed, :io, :compute
        or a j.u.c.ExecutorService object,
        default :mixed</pre></div></div><div class="public anchor" id="var-inject"><h3>inject</h3><div class="usage"><code>(inject g [pid io-id :as coord] msgs)</code></div><div class="doc"><pre class="plaintext">synchronously puts the messages on the channel corresponding to the
input or output of the process</pre></div></div><div class="public anchor" id="var-lift*-.3Estep"><h3>lift*-&gt;step</h3><div class="usage"><code>(lift*-&gt;step f)</code></div><div class="doc"><pre class="plaintext">given a fn f taking one arg and returning a collection of non-nil
values, create a 'step' fn as needed by step-process, with one input
and one output (named :in and :out), and no state.</pre></div></div><div class="public anchor" id="var-lift1-.3Estep"><h3>lift1-&gt;step</h3><div class="usage"><code>(lift1-&gt;step f)</code></div><div class="doc"><pre class="plaintext">like lift*-&gt;step except taking a fn returning one value, which, when
nil, will yield no output.</pre></div></div><div class="public anchor" id="var-pause"><h3>pause</h3><div class="usage"><code>(pause g)</code></div><div class="doc"><pre class="plaintext">pauses a running flow
</pre></div></div><div class="public anchor" id="var-pause-proc"><h3>pause-proc</h3><div class="usage"><code>(pause-proc g pid)</code></div><div class="doc"><pre class="plaintext">pauses a process
</pre></div></div><div class="public anchor" id="var-ping"><h3>ping</h3><div class="usage"><code>(ping g)</code></div><div class="doc"><pre class="plaintext">pings all processes, which will put their status and state on the
report channel returned from start</pre></div></div><div class="public anchor" id="var-ping-proc"><h3>ping-proc</h3><div class="usage"><code>(ping-proc g pid)</code></div><div class="doc"><pre class="plaintext">pings the process, which will put its status and state on the report
channel returned from start</pre></div></div><div class="public anchor" id="var-process"><h3>process</h3><div class="usage"><code>(process process-impl-map)</code><code>(process process-impl-map {:keys [workload timeout-ms], :or {timeout-ms 5000}, :as opts})</code></div><div class="doc"><pre class="plaintext">Given a map of functions (described below), returns a launcher that
creates a process compliant with the process protocol (see the
spi/ProcLauncher doc). The possible entries for process-impl-map
are :describe, :init, :transition, :transform and :introduce. This is
the core facility for defining the logic for processes via ordinary
functions.

:describe - required, () -&gt; desc
where desc is a map with keys :params :ins and :outs, each of which
in turn is a map of keyword to doc string, and :workload with
possible values of :mixed :io :compute. All entries in the describe
return map are optional.

:params describes the initial arguments to setup the state for the function.
:ins enumerates the input[s], for which the flow will create channels
:outs enumerates the output[s], for which the flow may create channels.
:workload - describes the nature of the workload, one of :mixed :io or :compute
        an :io workload should not do extended computation
        a :compute workload should never block

No key may be present in both :ins and :outs, allowing for a uniform
channel coordinate system of [:process-id :channel-id]. The
ins/outs/params returned will be the ins/outs/params of the
process. describe may be called by users to understand how to use
the proc. It will also be called by the impl in order to discover
what channels are needed.

:init - optional, (arg-map) -&gt; initial-state

init will be called once by the process to establish any
initial state. The arg-map will be a map of param-&gt;val, as supplied
in the flow def. init must be provided if 'describe' returns :params.

:transition - optional, (state transition) -&gt; state'

transition will be called when the process makes a state transition,
transition being one of ::flow/resume, ::flow/pause or ::flow/stop

With this fn a process impl can track changes and coordinate
resources, especially cleaning up any resources on :stop, since the
process will no longer be used following that. See the SPI for
details. state' will be the state supplied to subsequent calls.

Exactly one of either :transform or :introduce are required.

:transform - (state in-name msg) -&gt; [state' output]
where output is a map of outid-&gt;[msgs*]

The transform fn will be called every time a message arrives at any
of the inputs. Output can be sent to none, any or all of the :outs
enumerated, and/or an input named by a [pid inid] tuple (e.g. for
reply-to), and/or to the ::flow/report output. A step need not
output at all (output or msgs can be empyt/nil), however an output _message_
may never be nil (per core.async channels). state' will be the state
supplied to subsequent calls.

:introduce - (state) -&gt; [state' output]
where output is a map of outid-&gt;[msgs*], per :transform

The introduce fn is used for sources - proc-impls that introduce new data
into the flow by doing I/O with something external to the flow and
feeding that data to its outputs. A proc-impl specifying :introduce may not
specify any :ins in its descriptor, as none but the ::flow/control channel
will be read. Instead, introduce will be called every time through the
process loop, and will presumably do blocking or paced I/O to get
new data to return via its outputs. If it does blocking I/O it
should do so with a timeout so it can regularly return to the
process loop which can then look for control messages - it's fine
for introduce to return with no output. Do not spin poll in the introduce
fn.

process accepts an option map with keys:
:workload - one of :mixed, :io or :compute
:compute-timeout-ms - if :workload is :compute, this timeout (default 5000 msec)
              will be used when getting the return from the future - see below

A :workload supplied as an option to process will override
any :workload returned by the :describe fn of the process. If neither
are provded the default is :mixed.

The :compute workload is not allowed for proc impls that
provide :introduce (as I/O is presumed).

In the :workload context of :mixed or :io, this dictates the type of
thread in which the process loop will run, _including its calls to
transform/introduce_. 

When :io is specified transform/introduce should not do extensive computation.

When :compute is specified (only allowed for :transform), each call
to transform will be run in a separate thread. The process loop will
run in an :io context (since it no longer directly calls transform,
all it does is I/O) and it will submit transform to the :compute
executor then await (blocking, for compute-timeout-ms) the
completion of the future returned by the executor. If the future
times out it will be reported on ::flow/error.

When :compute is specified transform must not block!</pre></div></div><div class="public anchor" id="var-resume"><h3>resume</h3><div class="usage"><code>(resume g)</code></div><div class="doc"><pre class="plaintext">resumes a paused flow
</pre></div></div><div class="public anchor" id="var-resume-proc"><h3>resume-proc</h3><div class="usage"><code>(resume-proc g pid)</code></div><div class="doc"><pre class="plaintext">resumes a process
</pre></div></div><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start g)</code></div><div class="doc"><pre class="plaintext">starts the entire flow from init values. The processes start paused.
Call 'resume' or 'resume-proc' to start flow.  returns a map with keys:

:report-chan - a core.async chan for reading.'ping' reponses
will show up here, as will any explicit ::flow/report outputs
from :transform/:introduce

:error-chan - a core.async chan for reading. Any (and only)
exceptions thrown anywhere on any thread inside a flow will appear
in maps sent here. There will at least be a ::flow/ex entry with the
exception, and may be additional keys for pid, state, status etc
depending on the context of the error.</pre></div></div><div class="public anchor" id="var-step-process"><h3>step-process</h3><div class="usage"><code>(step-process f)</code><code>(step-process f opts)</code></div><div class="doc"><pre class="plaintext">Given a (e.g. communication-free) step function f of three
arities (described below), and the same opts as 'process', returns a
launcher that creates a process compliant with the process
protocol (see 'process').

The arities of f are:

()-&gt;desc
a function matching the semantics of process' :describe

(arg-map)-&gt;initial-state
a function matching the semantics of process' :init

(state in-name msg)-&gt;[state' output]
a function matching the semantics of process' :transform</pre></div></div><div class="public anchor" id="var-stop"><h3>stop</h3><div class="usage"><code>(stop g)</code></div><div class="doc"><pre class="plaintext">shuts down the flow, stopping all procsesses and closing the error
and report channels. The flow can be started again</pre></div></div></div></body></html>