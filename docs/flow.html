<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>core.async.flow #</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="flow.html"><div class="inner"><span>core.async.flow #</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></div></li><li class="depth-3"><a href="clojure.core.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-4"><a href="clojure.core.async.flow.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>flow</span></div></a></li><li class="depth-5"><a href="clojure.core.async.flow.spi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spi</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#coreasyncflow" id="coreasyncflow"></a>core.async.flow</h1>
<h2><a href="#rationale" id="rationale"></a>Rationale</h2>
<p>The <a href="https://clojure.org/news/2013/06/28/clojure-clore-async-channels">rationale</a> for <strong>core.async</strong> says “There comes a time in all good programs when components or subsystems must stop communicating directly with one another.” And core.async provides fundamental tools (channels) for doing that.</p>
<p>But using core.async well, e.g. keeping your I/O out of your computational logic, requires discipline and architectural savvy, and to do so consistently throughout an application or organization, conventions. Given channels, many architectural decisions remain regarding thread execution, backpressure, error handling etc. And often the topology of your network of communicating processes <em>emerges</em> out of the flow of control of your program as various pieces of code create threads and wire channels together, interleaved with computation, making it difficult to see the topology or administer it in one place.</p>
<p>The fundamental objective of <strong>core.async.flow</strong> is to enable a strict separation of your application logic from its topology, execution, communication, lifecycle, monitoring and error handling, all of which are provided by and centralized in, c.a.flow, yielding more consistent, robust, testable, observable and operable systems.</p>
<h2><a href="#overview" id="overview"></a>Overview</h2>
<p><strong>core.async.flow</strong> provides <em>concrete</em> implementations of two more abstractions - the ‘<strong>process</strong>’ - a thread of activity, and the ‘<strong>flow</strong>’ - a directed graph of processes communicating via channels. A single data structure describes your flow topology, and has all of the settings for threads, channels etc. A process accepts data from and provides data to channels. The process implementation in c.a.flow handles all channel I/O, thread lifecycle and coordination with the flow graph.</p>
<p>All you need to do in you application is:</p>
<ol>
<li>
<p>Define ordinary, often pure, data-&gt;data functions that the processes will run in their inner loop to do the <em>computational</em> part of processing messages. These functions do not handle channels or threads or lifecycle, and do not even know they are running in a flow. They can be tested in isolation, and hot-reloaded. If they encounter a problem they can, and should, just throw an exception. The process will take care of it from there.</p>
</li>
<li>
<p>Define a flow by creating a data structure that enumerates the processes and the connections between their inputs and outputs, as well as various configuration settings for both.</p>
</li>
</ol>
<p>With these application inputs, c.a.flow does the rest. It inquires of the processes what channels they require, creates those channels, then instantiates the processes making all of the channel connections between them. The processes in turn start threads (in fully user-configurable thread pools), await inputs, monitor the admin control channel, and when inputs arrive make data-&gt;data calls to your application logic, taking the return from that and sending it to the designated output channels. The processes follow a protocol used by the flow to do lifecycle management and error handling.</p>
<p>Once you’ve created a flow, the API provides functions to start/stop(shutdown) the flow, and to pause/resume both the flow and individual processes, to ping processes to get their state and that of their connected channels, to inject data into any point in the graph etc. The flow provides channels containing the ordinary monitoring/reporting stream and, separately, the error stream.</p>
<p>The library provides many more details and features, including the ability to create, via ordinary functions, processes that act as <strong>sources</strong> (of data from outside the flow) or <strong>sinks</strong> (to recipients outside the flow) so you can situate your flow in a broader context while still coordinating resource management with the flow lifecycle.</p>
<p>I hope <strong>core.async.flow</strong> enables you to write more robust and smaller applications, with more focus on your domain logic and less on plumbing.</p>
<p>Rich Hickey 1/2025</p>
</div></div></div></body></html>